<!DOCTYPE html>
<html lang="fi">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MVR-Yhtymä Oy – Perehdytyslomake</title>
  <style>
    :root {
      --primary-color: #007bff;
      --primary-hover: #0056b3;
      --bg-light: #f5f5f5;
      --bg-white: #fff;
      --text-dark: #333;
      --radius: 8px;
      --spacing: 16px;
    }
    html, body {
      margin: 0; padding: 0; overflow-x: hidden;
    }
    *, *::before, *::after { box-sizing: border-box; }
    body {
      font-family: Arial, sans-serif; background: var(--bg-light);
      color: var(--text-dark); line-height: 1.5;
    }
    header {
      background: var(--bg-white); padding: var(--spacing);
      text-align: center; box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    header h1 { margin: 0; font-size: 2rem; }
    main {
      max-width: 900px; margin: var(--spacing) auto;
      padding: 0 var(--spacing);
    }
    section {
      background: var(--bg-white); margin-bottom: var(--spacing);
      padding: var(--spacing); border-radius: var(--radius);
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    }
    h2 {
      margin-top: 0; font-size: 1.5rem;
      border-bottom: 2px solid var(--primary-color);
      padding-bottom: 0.25em;
    }
    .form-grid {
      display: grid; grid-template-columns: 1fr; gap: var(--spacing);
    }
    @media (min-width: 600px) {
      .form-grid { grid-template-columns: 1fr 1fr; }
    }
    .form-group { display: flex; flex-direction: column; }
    label { font-weight: bold; margin-bottom: 0.5em; }
    input, select, textarea, button, canvas {
      font-size: 1rem; padding: 0.5em; border: 1px solid #ccc;
      border-radius: var(--radius); width: 100%; max-width: 100%;
    }
    input:invalid, select:invalid { border-color: red; }
    button {
      margin-top: var(--spacing); background: var(--primary-color);
      color: var(--bg-white); border: none; cursor: pointer;
      transition: background 0.2s;
    }
    button:hover { background: var(--primary-hover); }
    .btn-group { display: flex; gap: var(--spacing); }
    .hidden { display: none; }
    ul { padding-left: 1em; margin: 0; }
    a { color: var(--primary-color); text-decoration: none; }
    a:hover { text-decoration: underline; }
    canvas.signature {
      border: 1px solid #ccc; cursor: crosshair;
      height: 200px; width: 100%;
    }
    #camera-modal {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(255,255,255,0.9); display: flex;
      flex-direction: column; justify-content: center; align-items: center;
      z-index: 1000;
    }
    #camera-modal.hidden { display: none; }
    #camera-video {
      position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      object-fit: cover;
    }
    .camera-overlay {
      position: absolute; top: 50%; left: 50%;
      width: 300px; height: 190px; margin-left: -150px;
      margin-top: -95px; box-shadow: 0 0 0 2000px rgba(255,255,255,0.8);
      border: 2px dashed var(--primary-color); border-radius: 8px;
    }
    .camera-controls {
      position: absolute; bottom: var(--spacing);
      display: flex; gap: var(--spacing);
    }
  </style>

  <!-- Google API + EmailJS -->
  <script src="https://apis.google.com/js/api.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/emailjs-com@2/dist/email.min.js"></script>
  <script>
    // Initialize EmailJS
    emailjs.init('GrJbR0Z9xXufM9WoR');

    // Load and init Google API client
    async function loadGapi() {
      return new Promise(resolve => gapi.load('client:auth2', resolve));
    }
    (async function() {
      await loadGapi();
      await gapi.client.init({
        apiKey: 'AIzaSyBukMVgGlG1WLxG3hW5BvyTsjoIVyRdX_o',
        clientId: '781486178828-pius6hn6vcirpo3b2ggqpnlfnsqq3ulc.apps.googleusercontent.com',
        discoveryDocs: ['https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'],
        scope: 'https://www.googleapis.com/auth/drive.file'
      });
    })();

    // Ensure user signed in and return access token
    async function ensureSignedIn() {
      const auth = gapi.auth2.getAuthInstance();
      if (!auth.isSignedIn.get()) {
        await auth.signIn();
      }
      return auth.currentUser.get().getAuthResponse().access_token;
    }

    // Upload a Blob to Google Drive and return webViewLink
    async function uploadBlobToDrive(blob, filename) {
      const token = await ensureSignedIn();
      const metadata = { name: filename, mimeType: blob.type };
      const boundary = '-------314159265358979323846';
      const delim = "\r\n--" + boundary + "\r\n";
      const close = "\r\n--" + boundary + "--";
      const reader = new FileReader();

      return new Promise((resolve, reject) => {
        reader.onload = async () => {
          try {
            const base64Data = btoa(
              new Uint8Array(reader.result)
                .reduce((data, byte) => data + String.fromCharCode(byte), '')
            );
            const multipartRequestBody =
              delim +
              'Content-Type: application/json; charset=UTF-8\r\n\r\n' +
              JSON.stringify(metadata) +
              delim +
              'Content-Type: ' + blob.type + '\r\n' +
              'Content-Transfer-Encoding: base64\r\n\r\n' +
              base64Data +
              close;

            const response = await fetch(
              'https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart&fields=webViewLink',
              {
                method: 'POST',
                headers: {
                  'Authorization': 'Bearer ' + token,
                  'Content-Type': 'multipart/related; boundary=' + boundary
                },
                body: multipartRequestBody
              }
            );
            const json = await response.json();
            if (!response.ok || !json.webViewLink) {
              throw new Error('Drive API error: ' + JSON.stringify(json));
            }
            resolve(json.webViewLink);
          } catch (e) {
            console.error('uploadBlobToDrive error:', e);
            reject(new Error(e.message || JSON.stringify(e)));
          }
        };
        reader.onerror = err => {
          reject(new Error('FileReader error: ' + err));
        };
        reader.readAsArrayBuffer(blob);
      });
    }
  </script>
</head>
<body>
  <header>
    <h1>MVR-Yhtymä Oy</h1>
    <p>Perehdytyslomake – Bss + SKiB Kampus työmaa</p>
  </header>
  <main>
    <form id="orientationForm">
      <!-- Osa 1 -->
      <section>
        <h2>Osa 1 – Perehdytys</h2>
        <div class="form-group">
          <label>FOREIGN PERSONS</label>
          <a href="https://forms.office.com/e/rSUhYcH6DK" target="_blank">Suorita perehdytys tästä</a>
        </div>
        <div class="form-grid">
          <div class="form-group">
            <label for="valtti">1. VALTTI-kortin numero (12 numeroa)</label>
            <input id="valtti" name="valtti" type="text" inputmode="numeric" pattern="\d{12}" required placeholder="123456789012" />
          </div>
          <div class="form-group">
            <button type="button" id="open-camera">Ota kuva kortista</button>
            <input type="hidden" name="card_photo_data" id="card_photo_data" />
            <img id="card-photo-preview" class="hidden" alt="Korttikuvan esikatselu" />
          </div>
          <!-- ... muut lomakekentät osioissa 1–11 ... -->
        </div>
      </section>

      <!-- Osa 12 – Allekirjoitus -->
      <section>
        <h2>Osa 12 – Allekirjoitus</h2>
        <div class="form-group">
          <label for="signature-pad">22. Allekirjoitus</label>
          <canvas id="signature-pad" class="signature"></canvas>
        </div>
        <div class="btn-group">
          <button type="button" id="clear-signature">Tyhjennä allekirjoitus</button>
        </div>
        <input type="hidden" name="signature_data" id="signature_data" required />
      </section>

      <button type="submit">Lähetä lomake</button>
    </form>

    <!-- Kamera-modali -->
    <div id="camera-modal" class="hidden">
      <video id="camera-video" autoplay playsinline></video>
      <div class="camera-overlay"></div>
      <div class="camera-controls">
        <button type="button" id="take-photo">Ota kuva</button>
        <button type="button" id="close-camera">Peruuta</button>
      </div>
    </div>
  </main>

  <script>
    // Signature pad + scroll lock
    const body = document.body;
    const canvasSig = document.getElementById('signature-pad');
    const ctxSig = canvasSig.getContext('2d');
    let drawing = false, lastX = 0, lastY = 0, origOverflow;

    function resizeSignature() {
      const ratio = window.devicePixelRatio || 1;
      const w = canvasSig.offsetWidth, h = canvasSig.offsetHeight;
      canvasSig.width = w * ratio;
      canvasSig.height = h * ratio;
      ctxSig.scale(ratio, ratio);
      ctxSig.lineCap = 'round';
      ctxSig.lineJoin = 'round';
      ctxSig.lineWidth = 2;
      ctxSig.clearRect(0, 0, w, h);
    }
    window.addEventListener('resize', resizeSignature);
    resizeSignature();

    function startSignature(e) {
      e.preventDefault();
      drawing = true;
      origOverflow = body.style.overflow;
      body.style.overflow = 'hidden';
      const rect = canvasSig.getBoundingClientRect();
      lastX = (e.clientX||e.touches[0].clientX) - rect.left;
      lastY = (e.clientY||e.touches[0].clientY) - rect.top;
    }
    function endSignature() {
      drawing = false;
      body.style.overflow = origOverflow;
    }
    function drawSignature(e) {
      if (!drawing) return;
      e.preventDefault();
      const rect = canvasSig.getBoundingClientRect();
      const x = (e.clientX||e.touches[0].clientX) - rect.left;
      const y = (e.clientY||e.touches[0].clientY) - rect.top;
      ctxSig.beginPath();
      ctxSig.moveTo(lastX, lastY);
      ctxSig.lineTo(x, y);
      ctxSig.stroke();
      lastX = x; lastY = y;
    }
    ['pointerdown','touchstart'].forEach(evt => canvasSig.addEventListener(evt, startSignature));
    ['pointerup','pointerout','touchend','touchcancel'].forEach(evt => canvasSig.addEventListener(evt, endSignature));
    ['pointermove','touchmove'].forEach(evt => canvasSig.addEventListener(evt, drawSignature));
    document.getElementById('clear-signature').addEventListener('click', resizeSignature);

    // Camera modal logic
    const openCam = document.getElementById('open-camera');
    const camModal = document.getElementById('camera-modal');
    const video = document.getElementById('camera-video');
    const takePhoto = document.getElementById('take-photo');
    const closePhoto = document.getElementById('close-camera');
    const cardInput = document.getElementById('card_photo_data');
    const cardPreview = document.getElementById('card-photo-preview');
    let camStream;

    openCam.addEventListener('click', async () => {
      camModal.classList.remove('hidden');
      try {
        camStream = await navigator.mediaDevices.getUserMedia({
          video: { facingMode: 'environment', width: { ideal: 4096 }, height: { ideal: 2160 } }
        });
        video.srcObject = camStream;
      } catch (err) {
        alert('Kameran käyttö ei onnistu: ' + (err.message || err));
        camModal.classList.add('hidden');
      }
    });

    takePhoto.addEventListener('click', async () => {
      const w = video.videoWidth, h = video.videoHeight;
      const tmp = document.createElement('canvas');
      tmp.width = w; tmp.height = h;
      tmp.getContext('2d').drawImage(video, 0, 0, w, h);

      const rect = document.querySelector('.camera-overlay').getBoundingClientRect();
      const vidRect = video.getBoundingClientRect();
      const scaleX = w / vidRect.width, scaleY = h / vidRect.height;
      const sx = (rect.left - vidRect.left) * scaleX;
      const sy = (rect.top - vidRect.top) * scaleY;
      const sw = rect.width * scaleX, sh = rect.height * scaleY;
      const crop = document.createElement('canvas');
      crop.width = sw; crop.height = sh;
      crop.getContext('2d').drawImage(tmp, sx, sy, sw, sh, 0, 0, sw, sh);

      try {
        const blob = await new Promise(r => crop.toBlob(r, 'image/jpeg', 0.7));
        const url = await uploadBlobToDrive(blob, 'valtti_' + Date.now() + '.jpg');
        cardInput.value = url;
        cardPreview.src = url;
        cardPreview.classList.remove('hidden');
      } catch (e) {
        console.error('Drive-latausvirhe:', e);
        alert('Drive-lataus epäonnistui: ' + (e.message || JSON.stringify(e)));
      }

      camModal.classList.add('hidden');
      camStream.getTracks().forEach(t => t.stop());
    });

    closePhoto.addEventListener('click', () => {
      camModal.classList.add('hidden');
      if (camStream) camStream.getTracks().forEach(t => t.stop());
    });

    // EmailJS submission
    document.getElementById('orientationForm').addEventListener('submit', async function(e) {
      e.preventDefault();
      try {
        const sigBlob = await new Promise(r => canvasSig.toBlob(r, 'image/jpeg', 0.7));
        const sigUrl = await uploadBlobToDrive(sigBlob, 'sig_' + Date.now() + '.jpg');
        document.getElementById('signature_data').value = sigUrl;

        await emailjs.sendForm('service_bvdu9lj', 'template_hlooz52', this);
        alert('Lomake lähetetty onnistuneesti!');
      } catch (err) {
        console.error('Lähetysvirhe:', err);
        alert('Lähetys epäonnistui: ' + (err.message || JSON.stringify(err)));
      }
    });
  </script>
</body>
</html>
